
----------- MODIFYING DATA -----------------------------------------

-- INSERTING

CREATE TABLE discounts (
    discount_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    discount_name VARCHAR2(255) NOT NULL,
    amount NUMBER(3,1) NOT NULL,
    start_date DATE NOT NULL,
    expired_date DATE NOT NULL
);

INSERT INTO discounts(discount_name, amount, start_date, expired_date)
VALUES('Summer Promotion', 9.5, DATE '2017-05-01', DATE '2017-08-31');

-- Sometimes, you want to select data from a table and insert it into another table. 
-- To do it, you use the Oracle INSERT INTO SELECT statement

CREATE TABLE sales (
    customer_id NUMBER,
    product_id NUMBER,
    order_date DATE NOT NULL,
    total NUMBER(9,2) DEFAULT 0 NOT NULL,
    PRIMARY KEY(customer_id,
                product_id,
                order_date)
);

INSERT INTO  sales(customer_id, product_id, order_date, total)
SELECT customer_id,
       product_id,
       order_date,
       SUM(quantity * unit_price) amount
FROM orders
INNER JOIN order_items USING(order_id)
WHERE status = 'Shipped'
GROUP BY customer_id,
         product_id,
         order_date;
         
         
-- To changes existing values in a table, you use the following Oracle UPDATE statement:

CREATE TABLE parts (
  part_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
  part_name VARCHAR(50) NOT NULL,
  lead_time NUMBER(2,0) NOT NULL,
  cost NUMBER(9,2) NOT NULL,
  status NUMBER(1,0) NOT NULL,
  PRIMARY KEY (part_id)
);

INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('sed dictum',5,134,0);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('tristique neque',3,62,1);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('dolor quam,',16,82,1);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('nec, diam.',41,10,1);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('vitae erat',22,116,0);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('parturient montes,',32,169,1);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('metus. In',45,88,1);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('at, velit.',31,182,0);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('nonummy ultricies',7,146,0);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('a, dui.',38,116,0);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('arcu et',37,72,1);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('sapien. Cras',40,197,1);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('et malesuada',24,46,0);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('mauris id',4,153,1);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('eleifend egestas.',2,146,0);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('cursus. Nunc',9,194,1);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('vivamus sit',37,93,0);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('ac orci.',35,134,0);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('arcu. Aliquam',36,154,0);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('at auctor',32,56,1);
INSERT INTO parts (part_name,lead_time,cost,status) VALUES ('purus, accumsan',33,12,1);

SELECT
    *
FROM
    parts
ORDER BY
    part_name;
    
-- Oracle UPDATE – update one column of a single row

UPDATE
    parts
SET
    cost = 130
WHERE
    part_id = 1;
    
-- Oracle UPDATE – update multiple columns of a single row

UPDATE
    parts
SET
    lead_time = 30,
    cost = 120,
    status = 1
WHERE
    part_id = 5;
    
-- Oracle UPDATE – update multiple rows example
-- The following statement increases the costs of all parts in the parts table 5%

UPDATE
    parts
SET
    cost = cost * 1.05;
    
    
-- To delete one or more rows from a table, you use the Oracle DELETE statement

CREATE TABLE sales AS
SELECT
    order_id,
    item_id,
    product_id,
    quantity,
    unit_price,
    status,
    order_date,
    salesman_id
FROM
    orders
INNER JOIN order_items
        USING(order_id);
        
-- Oracle DELETE – delete one row from a table

DELETE
FROM
    sales
WHERE
    order_id = 1
    AND item_id = 1;
    
-- Oracle DELETE – delete multiple rows from a table

DELETE
FROM
    sales
WHERE
    order_id = 1;
    
-- Oracle DELETE – delete all rows from a table

DELETE FROM sales;

-- Oracle DELETE – delete cascade
-- you often delete a row from a table which has a foreign key relationship with rows from other tables.
-- For example, you want to delete the sales order with id 1 from the orders table and also delete all the line 
-- items associated with the order id 1 from the order_items table. Typically, you can think of issuing two DELETE statements as follows:

DELETE
FROM
    orders
WHERE
    order_id = 1;

DELETE
FROM
    order_items
WHERE
    order_id = 1;

COMMIT WORK;

-- However, this is unnecessary if you know how to setup table’s constraint correctly.
-- In this case, when you create the order_items table, you define a foreign key constraint with the DELETE CASCADE option as follows

CREATE TABLE order_items 
(
    order_id   NUMBER( 12, 0 )                                , 
    -- other columns
    -- ...
    CONSTRAINT fk_order_items_orders 
    FOREIGN KEY( order_id ) 
    REFERENCES orders( order_id ) 
    ON DELETE CASCADE
);
    
    
-- By doing this, whenever you delete a row from the orders table, for example

DELETE
FROM
    orders
WHERE
    order_id = 1;
    
    
-- The Oracle MERGE statement selects data from one or more source tables and updates or inserts 
-- it into a target table. The MERGE statement allows you to specify a condition to determine 
-- whether to update data from or insert data into the target table.

CREATE TABLE members (
    member_id NUMBER PRIMARY KEY,
    first_name VARCHAR2(50) NOT NULL,
    last_name VARCHAR2(50) NOT NULL,
    rank VARCHAR2(20)
);

CREATE TABLE member_staging AS 
SELECT * FROM members;

-- insert into members table    
INSERT INTO members(member_id, first_name, last_name, rank) VALUES(1,'Abel','Wolf','Gold');
INSERT INTO members(member_id, first_name, last_name, rank) VALUES(2,'Clarita','Franco','Platinum');
INSERT INTO members(member_id, first_name, last_name, rank) VALUES(3,'Darryl','Giles','Silver');
INSERT INTO members(member_id, first_name, last_name, rank) VALUES(4,'Dorthea','Suarez','Silver');
INSERT INTO members(member_id, first_name, last_name, rank) VALUES(5,'Katrina','Wheeler','Silver');
INSERT INTO members(member_id, first_name, last_name, rank) VALUES(6,'Lilian','Garza','Silver');
INSERT INTO members(member_id, first_name, last_name, rank) VALUES(7,'Ossie','Summers','Gold');
INSERT INTO members(member_id, first_name, last_name, rank) VALUES(8,'Paige','Mcfarland','Platinum');
INSERT INTO members(member_id, first_name, last_name, rank) VALUES(9,'Ronna','Britt','Platinum');
INSERT INTO members(member_id, first_name, last_name, rank) VALUES(10,'Tressie','Short','Bronze');

-- insert into member_staging table
INSERT INTO member_staging(member_id, first_name, last_name, rank) VALUES(1,'Abel','Wolf','Silver');
INSERT INTO member_staging(member_id, first_name, last_name, rank) VALUES(2,'Clarita','Franco','Platinum');
INSERT INTO member_staging(member_id, first_name, last_name, rank) VALUES(3,'Darryl','Giles','Bronze');
INSERT INTO member_staging(member_id, first_name, last_name, rank) VALUES(4,'Dorthea','Gate','Gold');
INSERT INTO member_staging(member_id, first_name, last_name, rank) VALUES(5,'Katrina','Wheeler','Silver');
INSERT INTO member_staging(member_id, first_name, last_name, rank) VALUES(6,'Lilian','Stark','Silver');


-- When updating data from the members table to member_staging table, we should perform the following actions:
-- We update the rows with member id 1, 3, 4, and 6 because the rank or the last name of these members in these tables are different.
-- We insert the rows with member id 7 to 10 are because these rows exist in the members table but not in the member_staging table.

MERGE INTO member_staging x
USING (SELECT member_id, first_name, last_name, rank FROM members) y
ON (x.member_id  = y.member_id)
WHEN MATCHED THEN
    UPDATE SET x.first_name = y.first_name, 
                        x.last_name = y.last_name, 
                        x.rank = y.rank
    WHERE x.first_name <> y.first_name OR 
           x.last_name <> y.last_name OR 
           x.rank <> y.rank 
WHEN NOT MATCHED THEN
    INSERT(x.member_id, x.first_name, x.last_name, x.rank)  
    VALUES(y.member_id, y.first_name, y.last_name, y.rank);
    
    
-- Sometimes, you may want to insert multiple rows into a table or multiple tables. 
-- In this case, you use the Oracle INSERT ALL statement, which is also referred to as a multitable insert statement.

/*

INSERT ALL
    INTO table_name(col1,col2,col3) VALUES(val1,val2, val3)
    INTO table_name(col1,col2,col3) VALUES(val4,val5, val6)
    INTO table_name(col1,col2,col3) VALUES(val7,val8, val9)
Subquery;


In this statement, each value expression val1, val2, or val3 
must refer to a column returned by the select list of the subquery.

*/

CREATE TABLE fruits (
    fruit_name VARCHAR2(100) PRIMARY KEY,
    color VARCHAR2(100) NOT NULL
);

INSERT ALL 
    INTO fruits(fruit_name, color)
    VALUES ('Apple','Red') 

    INTO fruits(fruit_name, color)
    VALUES ('Orange','Orange') 

    INTO fruits(fruit_name, color)
    VALUES ('Banana','Yellow')
SELECT 1 FROM dual;


CREATE TABLE small_orders (
    order_id NUMBER(12) NOT NULL,
    customer_id NUMBER(6) NOT NULL,
    amount NUMBER(8,2) 
);

CREATE TABLE medium_orders AS
SELECT *
FROM small_orders;

CREATE TABLE big_orders AS
SELECT *
FROM small_orders;


INSERT ALL
   WHEN amount < 10000 THEN
      INTO small_orders
   WHEN amount >= 10000 AND amount <= 30000 THEN
      INTO medium_orders
   WHEN amount > 30000 THEN
      INTO big_orders
      
  SELECT order_id,
         customer_id,
         (quantity * unit_price) amount
  FROM orders
  INNER JOIN order_items USING(order_id);
  
-- CASE Expressions


-- The following query uses the CASE expression to calculate the discount for each product category i.e., 
-- CPU 5%, video card 10%, and other product categories 8%

SELECT
  product_name,
  list_price,
  CASE category_id
    WHEN 1
    THEN ROUND(list_price * 0.05,2) -- CPU
    WHEN 2
    THEN ROUND(List_price * 0.1,2)  -- Video Card
    ELSE ROUND(list_price * 0.08,2) -- other categories
  END discount
FROM
  products
ORDER BY
  product_name;
  
  
-- The following example uses the searched CASE expression to classify the products based on their list prices

SELECT
  product_name,
  list_price,
  CASE
    WHEN list_price > 0 AND list_price  < 600
        THEN 'Mass'
    WHEN list_price >= 600 AND list_price < 1000
        THEN 'Economy'
    WHEN list_price >= 1000 AND list_price < 2000
        THEN 'Luxury'
    ELSE 
        'Grand Luxury'
  END product_group
FROM
  products
WHERE
  category_id = 1
ORDER BY
  product_name;
  
-- The following query uses the CASE expression in an ORDER BY clause to determine the sort order of rows based on column value

SELECT
  *
FROM
  locations
WHERE country_id in ('US','CA','UK')
ORDER BY
   country_id,
  CASE country_id
    WHEN 'US'
    THEN state
    ELSE city
  END;
  
-- In the following query, we use the CASE expression in a HAVING clause to restrict rows returned by the SELECT statement
-- products -> order_items -> orders

SELECT 
   product_name, 
   category_id,
   COUNT(product_id)
FROM 
   order_items 
INNER JOIN products USING (product_id)
GROUP BY 
    product_name, 
    category_id
HAVING 
    COUNT(CASE WHEN category_id = 1 THEN product_id ELSE NULL END ) > 5 OR
    COUNT(CASE WHEN category_id = 2 THEN product_id ELSE NULL END) > 2
ORDER BY 
   product_name;
   
   
-- The following query finds all products whose gross margins are less than 12%

SELECT
  product_name,
  list_price,
  standard_cost,
  ROUND((list_price - standard_cost) * 100 / list_price,2) gross_margin
FROM
  products
WHERE
  ROUND((list_price - standard_cost) * 100 / list_price,2) < 12;
  

-- The following UPDATE statement uses the CASE expression to update the list price of the 
-- products whose gross margin are less than 12% to list prices that make their gross margin 12%

UPDATE
  products
SET
  list_price =
  CASE
    WHEN ROUND((list_price - standard_cost) * 100 / list_price,2) < 12
    THEN (standard_cost  + 1) * 12
  END
WHERE
  ROUND((list_price - standard_cost) * 100 / list_price,2) < 12;