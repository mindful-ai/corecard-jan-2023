-- CURSOR

-- A cursor is a pointer that points to a result of a query. 
-- PL/SQL has two types of cursors: implicit cursors and explicit cursors.
-- Oracle internally manages the whole execution cycle of implicit cursors 
-- and reveals only the cursorâ€™s information and statuses such as SQL%ROWCOUNT, 
-- SQL%ISOPEN, SQL%FOUND, and SQL%NOTFOUND

-- An explicit cursor is an SELECT statement declared explicitly in the declaration 
-- section of the current block or a package specification.
-- For an explicit cursor, you have control over its execution cycle from OPEN, FETCH, and CLOSE


CREATE VIEW sales2 AS
SELECT customer_id,
       SUM(unit_price * quantity) total,
       ROUND(SUM(unit_price * quantity) * 0.05) credit
FROM order_items
INNER JOIN orders USING (order_id)
WHERE status = 'Shipped'
GROUP BY customer_id;

-- Suppose you need to develop a anonymous block that:
-- Reset credit limits of all customers to zero.
-- Fetch customers sorted by sales in descending order and gives them new credit limits from a budget of 1 million.

-- A cursor has four attributes to which you can reference in the following format:
-- %ISOPEN, %FOUND, %NOTFOUND, %ROWCOUNT

DECLARE
  l_budget NUMBER := 1000000;
   -- cursor
  CURSOR c_sales IS
  SELECT  *  FROM sales2  
  ORDER BY total DESC;
   -- record    
   r_sales c_sales%ROWTYPE;
BEGIN

  -- reset credit limit of all customers
  UPDATE customers SET credit_limit = 0;

  OPEN c_sales;

  LOOP
    FETCH  c_sales  INTO r_sales;
    EXIT WHEN c_sales%NOTFOUND;

    -- update credit for the current customer
    UPDATE 
        customers
    SET  
        credit_limit = 
            CASE WHEN l_budget > r_sales.credit 
                        THEN r_sales.credit 
                            ELSE l_budget
            END
    WHERE 
        customer_id = r_sales.customer_id;

    --  reduce the budget for credit limit
    l_budget := l_budget - r_sales.credit;

    DBMS_OUTPUT.PUT_LINE( 'Customer id: ' ||r_sales.customer_id || ' Credit: ' || r_sales.credit || ' Remaining Budget: ' || l_budget );

    -- check the budget
    EXIT WHEN l_budget <= 0;
  END LOOP;

  CLOSE c_sales;
END;


-- PROCEDURE

-- A PL/SQL procedure is a reusable unit that encapsulates specific business logic of the application.
-- Technically speaking, a PL/SQL procedure is a named block stored as a schema object in the Oracle Database.

CREATE OR REPLACE PROCEDURE print_contact(
    in_customer_id NUMBER 
)
IS
  r_contact contacts%ROWTYPE;
BEGIN
  -- get contact based on customer id
  SELECT *
  INTO r_contact
  FROM contacts
  WHERE customer_id = in_customer_id;

  -- print out contact's information
  dbms_output.put_line( r_contact.first_name || ' ' || r_contact.last_name || '<' || r_contact.email ||'>' );

EXCEPTION
   WHEN OTHERS THEN
      dbms_output.put_line( SQLERRM );
END;

EXEC print_contact(1);


-- TRIGGER

--A trigger is a named PL/SQL block stored in the Oracle Database and executed automatically 
--when a triggering event takes place. The event can be any of the following:
--A data manipulation language  (DML) statement executed against a table e.g., INSERT, UPDATE, or DELETE. 
--For example, if you define a trigger that fires before an INSERT statement on the customers table, 
--the trigger will fire once before a new row is inserted into the customers table.
--A data definition language (DDL) statement executes e.g., CREATE or ALTER statement. 
--These triggers are often used for auditing purposes to record changes of the schema.
--A system event such as startup or shutdown of the Oracle Database.
--A user event such as login or logout.
--The act of executing a trigger is also known as firing a trigger. We say that the trigger is fired.

CREATE TABLE audits (
      audit_id         NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      table_name       VARCHAR2(255),
      transaction_name VARCHAR2(10),
      by_user          VARCHAR2(30),
      transaction_date DATE
);

CREATE OR REPLACE TRIGGER customers_audit_trg
    AFTER 
    UPDATE OR DELETE 
    ON customers
    FOR EACH ROW    
DECLARE
   l_transaction VARCHAR2(10);
BEGIN
   -- determine the transaction type
   l_transaction := CASE  
         WHEN UPDATING THEN 'UPDATE'
         WHEN DELETING THEN 'DELETE'
   END;

   -- insert a row into the audit table   
   INSERT INTO audits (table_name, transaction_name, by_user, transaction_date)
   VALUES('CUSTOMERS', l_transaction, USER, SYSDATE);
END;
/

UPDATE
   customers
SET
   credit_limit = 2000
WHERE
   customer_id =10;
   
SELECT * FROM audits;

DELETE FROM customers
WHERE customer_id = 10;

SELECT * FROM audits;
